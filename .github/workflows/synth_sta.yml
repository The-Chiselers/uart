name: Synthesis and Results

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
    
jobs:
  synth-and-publish:
    runs-on: ubuntu-latest
    # Ensures actions don't run on bot commits
    if: ${{ !contains(github.event.head_commit.message, '[gh-bot]') }}
    
    permissions:
      contents: write  # Needed to write back results

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for all branches and tags

      - name: Install Nix
        uses: cachix/install-nix-action@v27
        with:
          nix_path: nixpkgs=channel:nixos-unstable

      - name: Run Nix Cache
        uses: DeterminateSystems/magic-nix-cache-action@v2

      - name: Run Synthesis
        run: nix develop --command make synth

      - name: Run Static Timing Analysis
        run: nix develop --command make sta
        
      - name: Create output directory
        run: mkdir -p out/results
      
      - name: Extract synthesis results (for ALL configs)
        run: |
          # Prepare an empty JSON array to accumulate config results
          echo "[]" > out/results/synth_results.json

          # Prepare a file to accumulate table rows
          echo "" > out/results/synth_table_rows.tex

          # Find all config directories under out/synth
          CONFIG_DIRS=$(find out/synth -type d -name "*bits*sync*baud*" | sort)
          if [ -z "$CONFIG_DIRS" ]; then
            echo "Error: No synthesis results found in out/synth"
            exit 1
          fi

          for d in $CONFIG_DIRS; do
            echo "Parsing synthesis results in: $d"

            CONFIG_NAME=$(basename "$d")
            
            # Example: parse gate count from gates.txt
            # If gates.txt doesn't exist, fallback to "N/A"
            if [ -f "$d/gates.txt" ]; then
              CELL_COUNT=$(cat "$d/gates.txt")
            else
              CELL_COUNT="N/A"
            fi

            # Parse area from log.txt if it exists
            if [ -f "$d/log.txt" ]; then
              AREA=$(grep "Chip area" "$d/log.txt" | awk '{print $5}')
              COMBO_CELLS=$(grep "Combinational cells:" "$d/log.txt" | awk '{print $3}')
              SEQ_CELLS=$(grep "Sequential cells:" "$d/log.txt" | awk '{print $3}')
              BUF_INV_CELLS=$(grep "Buf/Inv cells:" "$d/log.txt" | awk '{print $3}')
            fi

            # Fallback if any are empty
            AREA="${AREA:-N/A}"
            COMBO_CELLS="${COMBO_CELLS:-N/A}"
            SEQ_CELLS="${SEQ_CELLS:-N/A}"
            BUF_INV_CELLS="${BUF_INV_CELLS:-N/A}"

            # If you want to parse FIFO depth or data bits from the directory name,
            # you can do something like:
            #   e.g. 8bits_2sync_900000baud -> dataBits=8, fifoDepth=2, baud=900000
            # This is just an example; adapt to your naming scheme.
            dataBits=$(echo "$CONFIG_NAME" | grep -oE '^[0-9]+bits' | sed 's/bits//')
            fifoDepth=$(echo "$CONFIG_NAME" | grep -oE '_[0-9]+sync_' | tr -dc '0-9')
            baud=$(echo "$CONFIG_NAME" | grep -oE '[0-9]+baud' | sed 's/baud//')

            dataBits="${dataBits:-N/A}"
            fifoDepth="${fifoDepth:-N/A}"
            baud="${baud:-N/A}"

            # For demonstration, let's define a module name
            MODULE_NAME="tech.rocksavage.chiselware.uart.Uart"

            # Add an object to the global JSON array
            newObj=$(jq -n \
              --arg cfg  "$CONFIG_NAME" \
              --arg db   "$dataBits" \
              --arg fd   "$fifoDepth" \
              --arg bd   "$baud" \
              --arg gates "$CELL_COUNT" \
              --arg area  "$AREA" \
              --arg combo "$COMBO_CELLS" \
              --arg seq   "$SEQ_CELLS" \
              --arg buf   "$BUF_INV_CELLS" \
              --arg module "$MODULE_NAME" \
              '{
                config_name: $cfg,
                data_bits: $db,
                fifo_depth: $fd,
                baud: $bd,
                cell_count: $gates,
                area: $area,
                combinational_cells: $combo,
                sequential_cells: $seq,
                buffer_inverter_cells: $buf,
                module: $module
              }'
            )
            tmp=$(mktemp)
            jq ". + [ $newObj ]" out/results/synth_results.json > "$tmp"
            mv "$tmp" out/results/synth_results.json

            # Append a row to the table snippet
            # Example table row:  configName | fifoDepth | dataBits | gateCount
            echo "\\texttt{$CONFIG_NAME} & $fifoDepth & $dataBits & $CELL_COUNT \\\\ \\hline" >> out/results/synth_table_rows.tex
          done

          # Now build a final .tex that wraps the rows in a table environment
          cat <<EOF > out/results/synth_results.tex
% Auto-generated table of all configs
\\renewcommand*{\\arraystretch}{1.3}
\\rowcolors{2}{gray!30}{gray!10}
\\begin{longtable}[H]{| p{0.22\\textwidth} | p{0.18\\textwidth} | p{0.20\\textwidth} | p{0.30\\textwidth} |}
\\hline
\\rowcolor{gray}
\\textcolor{white}{\\textbf{Config}} &
\\textcolor{white}{\\textbf{FIFO Depth}} &
\\textcolor{white}{\\textbf{Data Bits}} &
\\textcolor{white}{\\textbf{Gate Count}} \\\\ 
\\hline
\\endfirsthead

\\hline
\\rowcolor{gray}
\\textcolor{white}{\\textbf{Config}} &
\\textcolor{white}{\\textbf{FIFO Depth}} &
\\textcolor{white}{\\textbf{Data Bits}} &
\\textcolor{white}{\\textbf{Gate Count}} \\\\ 
\\hline
\\endhead

\\hline
\\endfoot
EOF

          # Insert all the rows we built
          cat out/results/synth_table_rows.tex >> out/results/synth_results.tex

          # Close the table
          cat <<EOF >> out/results/synth_results.tex
\\caption{Synthesis Results for All UART Configs}
\\end{longtable}
EOF

      - name: Extract STA results (optional, single or multiple)
        run: |
          # If you want to gather timing data for each config as well, do a similar loop:
          CONFIG_DIRS=$(find out/synth -type d -name "*bits*sync*baud*" | sort)
          if [ -z "$CONFIG_DIRS" ]; then
            echo "Error: No synthesis directories found for STA parsing."
            exit 1
          fi

          # For simplicity, let's just update the JSON array with a "timing" field
          for d in $CONFIG_DIRS; do
            CONFIG_NAME=$(basename "$d")

            # Attempt to parse timing from log.txt
            if [ -f "$d/log.txt" ]; then
              CLOCK_PERIOD=$(grep "Clock period:" "$d/log.txt" | awk '{print $3}')
              SLACK=$(grep "Slack:" "$d/log.txt" | head -1 | awk '{print $2}')
            fi

            CLOCK_PERIOD="${CLOCK_PERIOD:-5.0}"
            SLACK="${SLACK:-0.0}"

            MAX_FREQ=$(awk "BEGIN {print 1000/$CLOCK_PERIOD}" | xargs printf "%.2f")

            # Update the JSON object for this config
            tmp=$(mktemp)
            jq --arg cfg "$CONFIG_NAME" \
               --arg cp "$CLOCK_PERIOD" \
               --arg sl "$SLACK" \
               --arg mf "$MAX_FREQ" \
               'map(
                  if .config_name == $cfg then
                    .timing = {
                      "clock_period": $cp,
                      "slack": $sl,
                      "max_frequency_mhz": $mf
                    }
                  else
                    .
                  end
                )' out/results/synth_results.json > "$tmp"

            mv "$tmp" out/results/synth_results.json
          done

      - name: Generate Verilog
        run: nix develop --command make verilog
        
      - name: Commit results
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          git add --force out/results

          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "[gh-bot] Update synthesis and timing results"
            git pull --rebase origin main
            git push origin main
          fi
