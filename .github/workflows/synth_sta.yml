name: Synthesis and Results

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
    
jobs:
  synth-and-publish:
    runs-on: ubuntu-latest
    # Ensures actions don't run on bot commits
    if: ${{ !contains(github.event.head_commit.message, '[gh-bot]') }}
    
    permissions:
      contents: write  # Needed to write back results

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for all branches and tags

      - name: Install Nix
        uses: cachix/install-nix-action@v27
        with:
          nix_path: nixpkgs=channel:nixos-unstable

      - name: Run Nix Cache
        uses: DeterminateSystems/magic-nix-cache-action@v2

      - name: Run Synthesis
        run: nix develop --command make synth

      - name: Run Static Timing Analysis
        run: nix develop --command make sta
        
      - name: Create output directory
        run: mkdir -p out/results
      
      - name: Extract synthesis results
        run: |
          # Create output directory for results
          mkdir -p out/results
          
          # Find the latest synthesis directory
          LATEST_SYNTH_DIR=$(find out/synth -type d -name "*bits*sync*baud*" | sort | tail -n 1)
          echo "Using synthesis results from: $LATEST_SYNTH_DIR"
          
          if [ -z "$LATEST_SYNTH_DIR" ]; then
            echo "Error: No synthesis results found"
            exit 1
          fi
          
          # Extract key metrics from synthesis reports
          CONFIG_NAME=$(basename "$LATEST_SYNTH_DIR")
          MODULE_NAME=$(grep -o "module tech\.rocksavage\.chiselware\.[^ ]*" "$LATEST_SYNTH_DIR"/*.v 2>/dev/null | head -1 | cut -d' ' -f2 || echo "tech.rocksavage.chiselware.uart.Uart")
          CELL_COUNT=$(cat "$LATEST_SYNTH_DIR/gates.txt" 2>/dev/null || echo "N/A")
          
          # Parse area from log file
          AREA=$(grep "Chip area" "$LATEST_SYNTH_DIR/log.txt" 2>/dev/null | awk '{print $5}' || echo "N/A")
          
          # Extract additional metrics
          COMBO_CELLS=$(grep "Combinational cells:" "$LATEST_SYNTH_DIR/log.txt" 2>/dev/null | awk '{print $3}' || echo "N/A")
          SEQ_CELLS=$(grep "Sequential cells:" "$LATEST_SYNTH_DIR/log.txt" 2>/dev/null | awk '{print $3}' || echo "N/A")
          BUF_INV_CELLS=$(grep "Buf/Inv cells:" "$LATEST_SYNTH_DIR/log.txt" 2>/dev/null | awk '{print $3}' || echo "N/A")
          
          # Extract config parameters
          CONFIG_CLASS=$(grep "config-class" Makefile | head -1 | awk -F'--config-class' '{print $2}' | tr -d ' ')
          
          # Create JSON file with results
          cat > out/results/synth_results.json << EOF
          {
            "module": "$MODULE_NAME",
            "config_name": "$CONFIG_NAME",
            "config_class": "$CONFIG_CLASS",
            "commit_hash": "$(git rev-parse --short HEAD)",
            "synthesis_date": "$(date +'%Y-%m-%d')",
            "synthesis": {
              "cell_count": "$CELL_COUNT",
              "area": "$AREA",
              "combinational_cells": "$COMBO_CELLS",
              "sequential_cells": "$SEQ_CELLS",
              "buffer_inverter_cells": "$BUF_INV_CELLS"
            }
          }
          EOF
          
          # Create TEX file with variables
          cat > out/results/synth_results.tex << EOF
          % Synthesis Results Variables
          \\newcommand{\\moduleNameVar}{$MODULE_NAME}
          \\newcommand{\\configNameVar}{$CONFIG_NAME}
          \\newcommand{\\configClassVar}{$CONFIG_CLASS}
          \\newcommand{\\cellCountVar}{$CELL_COUNT}
          \\newcommand{\\areaVar}{$AREA}
          \\newcommand{\\synthesisDate}{$(date +'%Y-%m-%d')}
          \\newcommand{\\commitHash}{$(git rev-parse --short HEAD)}
          \\newcommand{\\combiCellsVar}{$COMBO_CELLS}
          \\newcommand{\\seqCellsVar}{$SEQ_CELLS}
          \\newcommand{\\bufInvCellsVar}{$BUF_INV_CELLS}
          EOF

      - name: Extract STA results
        run: |
          # Find the latest synthesis directory
          LATEST_SYNTH_DIR=$(find out/synth -type d -name "*bits*sync*baud*" | sort | tail -n 1)
          
          if [ -z "$LATEST_SYNTH_DIR" ]; then
            echo "Error: No synthesis results found"
            exit 1
          fi
          
          # Try to extract timing metrics from STA reports if they exist
          # Extract timing metrics from STA reports if they exist, otherwise use defaults
          CLOCK_PERIOD=$(grep "Clock period:" "$LATEST_SYNTH_DIR/log.txt" 2>/dev/null | awk '{print $3}' || echo "5.0")
          SLACK=$(grep "Slack:" "$LATEST_SYNTH_DIR/log.txt" 2>/dev/null | head -1 | awk '{print $2}' || echo "0.0")
          
          # Extract additional timing metrics if available, otherwise use placeholders
          CRITICAL_PATH=$(grep -A 1 "Critical path" "$LATEST_SYNTH_DIR/log.txt" 2>/dev/null | grep -v "Critical path" | head -1 | tr -s ' ' | cut -d' ' -f2- || echo "N/A")
          SETUP_TIME=$(grep "Setup time:" "$LATEST_SYNTH_DIR/log.txt" 2>/dev/null | awk '{print $3}' || echo "N/A") 
          HOLD_TIME=$(grep "Hold time:" "$LATEST_SYNTH_DIR/log.txt" 2>/dev/null | awk '{print $3}' || echo "N/A")
          
          # Calculate max frequency
          MAX_FREQ=$(awk "BEGIN {print 1000/$CLOCK_PERIOD}" | xargs printf "%.2f" 2>/dev/null || echo "200.00")
          
          # Update JSON file with STA results
          jq --arg clock "$CLOCK_PERIOD" \
             --arg slack "$SLACK" \
             --arg critical "$CRITICAL_PATH" \
             --arg setup "$SETUP_TIME" \
             --arg hold "$HOLD_TIME" \
             --arg max_freq "$MAX_FREQ" \
             '.timing = {"clock_period": $clock, "slack": $slack, "critical_path": $critical, "setup_time": $setup, "hold_time": $hold, "max_frequency_mhz": $max_freq}' \
             out/results/synth_results.json > temp.json && mv temp.json out/results/synth_results.json
          
          # Update TEX file with STA variables
          cat >> out/results/synth_results.tex << EOF
          \\newcommand{\\clockPeriodVar}{$CLOCK_PERIOD}
          \\newcommand{\\slackVar}{$SLACK}
          \\newcommand{\\maxFreqVar}{$MAX_FREQ}
          \\newcommand{\\staPassesVar}{$(if (( $(echo "$SLACK >= 0" | bc -l 2>/dev/null) )); then echo "Yes"; else echo "No"; fi)}
          \\newcommand{\\criticalPathVar}{$CRITICAL_PATH}
          \\newcommand{\\setupTimeVar}{$SETUP_TIME}
          \\newcommand{\\holdTimeVar}{$HOLD_TIME}
          EOF

      - name: Generate Verilog
        run: nix develop --command make verilog
        
      - name: Commit results
        run: |
          # Make sure we have the latest changes
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          # Stage the files (force add to override gitignore)
          git add --force out/results
          
          # Check if we have any changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            # Commit the changes
            git commit -m "[gh-bot] Update synthesis and timing results"
            
            # Pull with rebase to incorporate any remote changes
            git pull --rebase origin main
            
            # Push the changes
            git push origin main
          fi