\section{Register Interface}

The UART module is controlled via an APB interface that maps configuration, status, and data registers for both the transmitter (TX) and receiver (RX) sections. In the updated design, the module uses internal dynamic FIFOs to buffer data and a dedicated baud–rate generator to compute the effective clocks–per–bit. This section describes the register map and details the functionality of each register.

\subsection{Register Map Summary}

The table below summarizes the complete register space. All addresses assume a 32–bit APB data bus. Note that some registers (e.g. TX\_CLOCKS\_PER\_BIT and RX\_CLOCKS\_PER\_BIT) are computed dynamically and are read–only.
It should be noted that all registers are \textbf{Double Buffered} and are automatically synchronized. This means that settings can be configured without the need for software synchronization.

\renewcommand*{\arraystretch}{1.25}
\begingroup
\small
\rowcolors{2}{gray!30}{gray!10}
\arrayrulecolor{gray!80}
\begin{longtable}{|c|c|c|c|p{0.35\textwidth}|}
    \hline
    \rowcolor{gray}
    \textcolor{white}{\textbf{Relative Address}} & \textcolor{white}{\textbf{Register Name}} & \textcolor{white}{\textbf{Type}} & \textcolor{white}{\textbf{Reset Value}} & \textcolor{white}{\textbf{Description}} \\ \hline
    \endfirsthead

    \hline
    \rowcolor{gray}
    \textcolor{white}{\textbf{Relative Address}} & \textcolor{white}{\textbf{Register Name}} & \textcolor{white}{\textbf{Type}} & \textcolor{white}{\textbf{Reset Value}} & \textcolor{white}{\textbf{Description}} \\ \hline
    \endhead

    \hline
    \endfoot

    0x0 &
    TX\_LOAD\_OFFSET &
    R/W &
    0 &
    When set to 1, all data in the TX fifo is sent out sequentially. It is automatically reset to 0 and does not have to be reset.
    \\ \hline

    0x4 &
    TX\_DATAIN\_OFFSET &
    R/W & 0 &
    When set, the data is sent to the back of the TX FIFO. It is automatically reset to 0 and does not have to be reset.
    \\ \hline

    0x8 &
    TX\_BAUDRATE\_OFFSET &
    R/W &
    115,200 &
    Controls the baud rate of the module. Is updated after TX\_UPDATEBAUD is asserted.
    \\ \hline

    0xC &
    TX\_CLOCKFREQ\_OFFSET &
    R/W &
    25,000,000 &
    This does not control the clock frequency, it is used by the divider to configure the TX frequency and must match the module clock frequency. Is updated after TX\_UPDATEBAUD is asserted.
    \\ \hline

    0x10 &
    TX\_UPDATEBAUD\_OFFSET &
    R/W &
    0 &
    This tells the TX module to apply the changes in TX\_BAUDRATE, and TX\_CLOCKFREQ. It can take up to 32 cycles to converge.
    \\ \hline

    0x14 &
    TX\_NUMOUTPUTBITSDB\_OFFSET &
    R/W &
    8 &
    This controls the number of data bits in a TX transaction.
    \\ \hline


    0x18 &
    TX\_USEPARITYDB\_OFFSET &
    R/W &
    0 &
    This controls whether to use a parity bit in a TX transaction.
    \\ \hline

    0x1C &
    TX\_PARITYODDDB\_OFFSET &
    R/W &
    0 &
    This controls whether to use odd or even parity in a TX transaction.
    \\ \hline

    0x20 &
    TX\_ALMOSTEMPTYLEVEL\_OFFSET &
    R/W &
    1 &
    This is the level of the TX FIFO that triggers the TX\_FIFOALMOSTEMPTY flag.
    \\ \hline

    0x24 &
    TX\_ALMOSTFULLLEVEL\_OFFSET &
    R/W &
    bufferSize - 1 &
    This is the level of the TX FIFO that triggers the TX\_FIFOALMOSTFULL flag.
    \\ \hline

    0x28 &
    TX\_FIFOFULL\_OFFSET &
    R &
    0 &
    This flag is set when the TX FIFO is full.
    \\ \hline

    0x2C &
    TX\_FIFOEMPTY\_OFFSET &
    R &
    0 &
    This flag is set when the TX FIFO is empty.
    \\ \hline

    0x30 &
    TX\_FIFOALMOSTEMPTY\_OFFSET &
    R &
    0 &
    This flag is set when the TX FIFO is at or below the TX\_ALMOSTEMPTYLEVEL.
    \\ \hline

    0x34 &
    TX\_FIFOALMOSTFULL\_OFFSET &
    R &
    0 &
    This flag is set when the TX FIFO is at or above the TX\_ALMOSTFULLLEVEL.
    \\ \hline

    0x38 &
    RX\_DATA\_OFFSET &
    R &
    0 &
    Desc
    \\ \hline

    0x3C &
    RX\_DATAPEEK\_OFFSET &
    R &
    0 &
    Desc
    \\ \hline

    0x40 &
    RX\_DATAAVAILABLE\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline

    0x44 &
    ERROR\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline

    0x48 &
    CLEARERROR\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline

    0x4C &
    RX\_BAUDRATE\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline

    0x50 &
    RX\_CLOCKFREQ\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline

    0x54 &
    RX\_UPDATEBAUD\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline

    0x58 &
    RX\_NUMOUTPUTBITSDB\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline

    0x5C &
    RX\_USEPARITYDB\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline

    0x60 &
    RX\_PARITYODDDB\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline

    0x64 &
    RX\_ALMOSTEMPTYLEVEL\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline

    0x68 &
    RX\_ALMOSTFULLLEVEL\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline

    0x6C &
    RX\_FIFOFULL\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline

    0x70 &
    RX\_FIFOEMPTY\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline

    0x74 &
    RX\_FIFOALMOSTEMPTY\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline

    0x78 &
    RX\_FIFOALMOSTFULL\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline

    0x7C &
    RX\_CLOCKSPERBIT\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline

    0x80 &
    TX\_CLOCKSPERBIT\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline

    0x84 &
    RX\_LSBFIRST\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline

    0x88 &
    TX\_LSBFIRST\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline

    0x8C &
    RX\_FLUSH\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline

    0x90 &
    TX\_FLUSH\_OFFSET &
    R/W &
    0 &
    Desc
    \\ \hline
\end{longtable}
\captionof{table}{UART Register Map}
\label{table:uart_register_map}
\endgroup

\subsection{Parameter Relationships and Calculations}

\textbf{Key Parameter Relationships:}
\begin{itemize}
    \item \texttt{dataWidth}: Width of the APB data bus (e.g., 32 bits).
    \item \texttt{maxOutputBits}: Maximum number of data bits per frame (excluding start/stop bits). An extra bit is provided for parity when enabled.
    \item \texttt{maxClockFrequency}: The maximum system clock frequency used by the baud generators (e.g., 25\,MHz).
    \item \texttt{maxBaudRate}: The highest supported baud rate (e.g., 921600 baud).
    \item \texttt{bufferSize}: Defines the depth of the internal dynamic FIFOs used in both TX and RX.
\end{itemize}

\textbf{Width Calculations:}
\begin{itemize}
    \item \texttt{TX\_DATA\_IN} / \texttt{RX\_DATA}: Width = \(\text{maxOutputBits}+1\). The extra bit is used to accommodate an optional parity bit.
    \item \texttt{TX\_NUM\_OUTPUT\_BITS\_DB} / \texttt{RX\_NUM\_OUTPUT\_BITS\_DB}: Width = \(\lceil\log_2(\text{maxOutputBits})\rceil+1\).

    \textit{Example:} For \(\text{maxOutputBits}=8\), the width is \(\lceil\log_2(8)\rceil+1 = 3+1 = 4\) bits.

    \item \texttt{TX\_CLOCKS\_PER\_BIT} / \texttt{RX\_CLOCKS\_PER\_BIT}: Width = \(\lceil\log_2(\tfrac{\text{maxClockFrequency}}{\text{maxBaudRate}})\rceil+1\).

    \textit{Example:} For a 25\,MHz clock and 921600 baud, the width is \(\lceil\log_2(25\,000\,000/921600)\rceil+1 \approx \lceil4.76\rceil+1 = 5+1 = 6\) bits.
\end{itemize}

\subsection{Key Register Descriptions}

\subsubsection{TX\_DATA\_IN (Address 0x00)}
\begin{itemize}[noitemsep]
    \item \textbf{Function:} Holds the data word to be transmitted.
    \item \textbf{Usage:} Software writes the desired value (e.g., an 8-bit word with an extra parity bit if used) before triggering transmission.
    \item \textbf{Reset Value:} 0x000.
\end{itemize}

\subsubsection{TX\_LOAD (Address 0x04)}
\begin{itemize}[noitemsep]
    \item \textbf{Function:} Triggers the transfer of the content in TX\_DATA\_IN into the TX FIFO.
    \item \textbf{Usage:} Write ‘1’ to this register to push the data into the FIFO. It auto–clears after one cycle.
    \item \textbf{Reset Value:} 0x0.
\end{itemize}

\subsubsection{TX\_BAUD\_RATE (Address 0x08) \& TX\_CLOCK\_FREQ (Address 0x0C)}
\begin{itemize}[noitemsep]
    \item \textbf{Function:}
    \begin{itemize}
        \item TX\_BAUD\_RATE sets the desired baud rate (e.g., 115200).
        \item TX\_CLOCK\_FREQ specifies the system clock frequency driving the baud generator.
    \end{itemize}
    \item \textbf{Usage:} After writing these registers, software must pulse TX\_UPDATE\_BAUD to update the baud divisor.
    \item \textbf{Reset Values:} 115200 and 25,000,000 respectively.
\end{itemize}

\subsubsection{TX\_UPDATE\_BAUD (Address 0x10)}
\begin{itemize}[noitemsep]
    \item \textbf{Function:} Triggers an update of the TX baud divisor.
    \item \textbf{Usage:} A pulse (write ‘1’) causes the UartBaudRateGenerator to compute a new \texttt{clocksPerBit} value, which is then stored in TX\_CLOCKS\_PER\_BIT.
    \item \textbf{Reset Value:} 0x0.
\end{itemize}

\subsubsection{TX\_NUM\_OUTPUT\_BITS\_DB (Address 0x14)}
\begin{itemize}[noitemsep]
    \item \textbf{Function:} Configures the number of data bits to be transmitted.
    \item \textbf{Usage:} Valid values typically range from 5 to \texttt{maxOutputBits}. The setting takes effect on the next transmission.
    \item \textbf{Reset Value:} 0x8 (for an 8-bit frame).
\end{itemize}

\subsubsection{TX\_USE\_PARITY\_DB (Address 0x18) and TX\_PARITY\_ODD\_DB (Address 0x1C)}
\begin{itemize}[noitemsep]
    \item \textbf{Function:}
    \begin{itemize}
        \item TX\_USE\_PARITY\_DB enables parity generation when set to ‘1’.
        \item TX\_PARITY\_ODD\_DB selects odd parity if ‘1’; if ‘0’, even parity is used.
    \end{itemize}
    \item \textbf{Usage:} Set these registers appropriately to control parity on transmission.
    \item \textbf{Reset Values:} Both default to 0 (parity disabled).
\end{itemize}

\subsubsection{TX\_CLOCKS\_PER\_BIT (Address 0x20)}
\begin{itemize}[noitemsep]
    \item \textbf{Function:} Contains the calculated number of clock cycles per transmitted bit.
    \item \textbf{Usage:} This read–only value is computed by the TX baud generator after a TX\_UPDATE\_BAUD pulse.
    \item \textbf{Reset Value:} Dynamically calculated.
\end{itemize}

\subsubsection{RX\_DATA (Address 0x24)}
\begin{itemize}[noitemsep]
    \item \textbf{Function:} Holds the data word received by the UART.
    \item \textbf{Usage:} After successful reception and FIFO push, software reads RX\_DATA to retrieve the word.
    \item \textbf{Reset Value:} 0x000.
\end{itemize}

\subsubsection{RX\_DATA\_AVAILABLE (Address 0x28)}
\begin{itemize}[noitemsep]
    \item \textbf{Function:} Indicates whether new data is available in the RX FIFO.
    \item \textbf{Usage:} Poll this register to determine when data is ready for reading.
    \item \textbf{Reset Value:} 0x0.
\end{itemize}

\subsubsection{RX\_ERROR (Address 0x2C)}
\begin{itemize}[noitemsep]
    \item \textbf{Function:} Reports reception errors:
    \begin{itemize}
        \item 00: No error.
        \item 01: Parity error.
        \item 10: Framing error.
        \item 11: Overrun error.
    \end{itemize}
    \item \textbf{Usage:} Monitor this register to detect errors; errors are cleared by writing to RX\_CLEAR\_ERROR.
    \item \textbf{Reset Value:} 0x0.
\end{itemize}

\subsubsection{TOP\_ERROR (Address 0x30)}
\begin{itemize}[noitemsep]
    \item \textbf{Function:} Indicates configuration or top–level errors.
    \item \textbf{Usage:} Software should check this register to ensure the module is correctly configured.
    \item \textbf{Reset Value:} 0x0.
\end{itemize}

\subsubsection{RX\_CLEAR\_ERROR (Address 0x34)}
\begin{itemize}[noitemsep]
    \item \textbf{Function:} Clears the RX error flags (in RX\_ERROR).
    \item \textbf{Usage:} Write ‘1’ to reset any error status.
    \item \textbf{Reset Value:} 0x0.
\end{itemize}

\subsubsection{RX\_BAUD\_RATE (Address 0x38) and RX\_CLOCK\_FREQ (Address 0x3C)}
\begin{itemize}[noitemsep]
    \item \textbf{Function:}
    \begin{itemize}
        \item RX\_BAUD\_RATE: Desired baud rate for reception.
        \item RX\_CLOCK\_FREQ: System clock frequency for the RX baud generator.
    \end{itemize}
    \item \textbf{Usage:} Configure these values similarly to the TX side.
    \item \textbf{Reset Values:} 115200 for RX\_BAUD\_RATE and 25,000,000 for RX\_CLOCK\_FREQ.
\end{itemize}

\subsubsection{RX\_UPDATE\_BAUD (Address 0x40)}
\begin{itemize}[noitemsep]
    \item \textbf{Function:} Triggers an update of the RX baud divisor.
    \item \textbf{Usage:} Pulse ‘1’ to have the UartBaudRateGenerator recalculate the effective clocks–per–bit.
    \item \textbf{Reset Value:} 0x0.
\end{itemize}

\subsubsection{RX\_NUM\_OUTPUT\_BITS\_DB (Address 0x44)}
\begin{itemize}[noitemsep]
    \item \textbf{Function:} Sets the expected number of data bits per received frame.
    \item \textbf{Usage:} This value must match the transmitter’s setting to avoid framing errors.
    \item \textbf{Reset Value:} 0x8.
\end{itemize}

\subsubsection{RX\_USE\_PARITY\_DB (Address 0x48) and RX\_PARITY\_ODD\_DB (Address 0x4C)}
\begin{itemize}[noitemsep]
    \item \textbf{Function:}
    \begin{itemize}
        \item RX\_USE\_PARITY\_DB: Enables parity checking when set to ‘1’.
        \item RX\_PARITY\_ODD\_DB: Selects odd parity if ‘1’ (even parity if ‘0’).
    \end{itemize}
    \item \textbf{Usage:} Configure these registers as needed for the desired parity configuration.
    \item \textbf{Reset Values:} Both default to 0.
\end{itemize}

\subsubsection{RX\_CLOCKS\_PER\_BIT (Address 0x50)}
\begin{itemize}[noitemsep]
    \item \textbf{Function:} Contains the computed number of system clock cycles per received bit.
    \item \textbf{Usage:} This read–only value is generated by the RX baud generator and used internally for sampling.
    \item \textbf{Reset Value:} Calculated dynamically.
\end{itemize}

\subsection{Programming Template}

Below is an example header file and source file to use the Uart module.

\subsubsection{Header File}

\begin{lstlisting}[language=C,frame=single,label={lst:header}]

#ifndef REGISTER_MAP_H
#define REGISTER_MAP_H

#define TX_LOAD_OFFSET 0x0
#define TX_DATAIN_OFFSET 0x4
#define TX_BAUDRATE_OFFSET 0x8
#define TX_CLOCKFREQ_OFFSET 0xC
#define TX_UPDATEBAUD_OFFSET 0x10
#define TX_NUMOUTPUTBITSDB_OFFSET 0x14
#define TX_USEPARITYDB_OFFSET 0x18
#define TX_PARITYODDDB_OFFSET 0x1C
#define TX_ALMOSTEMPTYLEVEL_OFFSET 0x20
#define TX_ALMOSTFULLLEVEL_OFFSET 0x24
#define TX_FIFOFULL_OFFSET 0x28
#define TX_FIFOEMPTY_OFFSET 0x2C
#define TX_FIFOALMOSTEMPTY_OFFSET 0x30
#define TX_FIFOALMOSTFULL_OFFSET 0x34
#define RX_DATA_OFFSET 0x38
#define RX_DATAPEEK_OFFSET 0x3C
#define RX_DATAAVAILABLE_OFFSET 0x40
#define ERROR_OFFSET 0x44
#define CLEARERROR_OFFSET 0x48
#define RX_BAUDRATE_OFFSET 0x4C
#define RX_CLOCKFREQ_OFFSET 0x50
#define RX_UPDATEBAUD_OFFSET 0x54
#define RX_NUMOUTPUTBITSDB_OFFSET 0x58
#define RX_USEPARITYDB_OFFSET 0x5C
#define RX_PARITYODDDB_OFFSET 0x60
#define RX_ALMOSTEMPTYLEVEL_OFFSET 0x64
#define RX_ALMOSTFULLLEVEL_OFFSET 0x68
#define RX_FIFOFULL_OFFSET 0x6C
#define RX_FIFOEMPTY_OFFSET 0x70
#define RX_FIFOALMOSTEMPTY_OFFSET 0x74
#define RX_FIFOALMOSTFULL_OFFSET 0x78
#define RX_CLOCKSPERBIT_OFFSET 0x7C
#define TX_CLOCKSPERBIT_OFFSET 0x80
#define RX_LSBFIRST_OFFSET 0x84
#define TX_LSBFIRST_OFFSET 0x88
#define RX_FLUSH_OFFSET 0x8C
#define TX_FLUSH_OFFSET 0x90

#endif REGISTER_MAP_H
\end{lstlisting}

\subsubsection{TX Source File}
\begin{lstlisting}[language=C,frame=single,label={lst:tx-source}]

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <stdint.h>
#include "uartRegs.h"

// Base address for the UART registers and mapping size
#define UART_BASE 0x43C20000
#define REG_SIZE  0x1000

// Transmitter register offsets (32-bit registers)

// Hypothetical TX FIFO empty flag register offset.
// Assumed to return 1 when the FIFO is empty.
//#define TX_FIFO_EMPTY_OFFSET          0x60

int main(void)
{
    int fd = open("/dev/mem", O_RDWR | O_SYNC);
    if(fd < 0) {
        perror("Failed to open /dev/mem");
        return -1;
    }

    volatile uint8_t *base = mmap(NULL, REG_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, UART_BASE);
    if(base == MAP_FAILED) {
        perror("Failed to mmap UART registers");
        close(fd);
        return -1;
    }

    // 1. Configure TX baud rate and data format
    *(volatile uint32_t *)(base + TX_CLOCKFREQ_OFFSET)         = 50000000;  // Set TX system clock frequency to 25 MHz
    *(volatile uint32_t *)(base + TX_BAUDRATE_OFFSET)            = 115200;    // Set desired baud rate to 115200
    *(volatile uint32_t *)(base + TX_UPDATEBAUD_OFFSET)          = 1;         // Trigger TX baud rate update
    *(volatile uint32_t *)(base + TX_NUMOUTPUTBITSDB_OFFSET)   = 8;         // Configure for 8 data bits per frame
    *(volatile uint32_t *)(base + TX_USEPARITYDB_OFFSET)        = 0;         // Disable parity
    *(volatile uint32_t *)(base + TX_PARITYODDDB_OFFSET)        = 0;         // (Ignored if parity is disabled)

    // 2. Enqueue data for transmission
    *(volatile uint32_t *)(base + TX_DATAIN_OFFSET) = 0x33;         // Write data word (0x55)
    *(volatile uint32_t *)(base + TX_LOAD_OFFSET)    = 1;            // Pulse 'load' to push data into TX FIFO

    printf("Data transmitted successfully.\n");

    munmap((void *)base, REG_SIZE);
    close(fd);
    return 0;
}
\end{lstlisting}

\subsubsection{RX Source File}
\begin{lstlisting}[language=C,frame=single,label={lst:rx-source}]
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <stdint.h>
#include "uartRegs.h"

#define UART_BASE 0x43C30000
#define REG_SIZE  0x1000

// Receiver register offsets (32-bit registers)
// Hypothetical register to indicate that data has been read (pop the RX FIFO)
// Not in the original map but referenced by the pseudocode.

int main(void)
{
    int fd = open("/dev/mem", O_RDWR | O_SYNC);
    if(fd < 0) {
        perror("Failed to open /dev/mem");
        return -1;
    }

    volatile uint8_t *base = mmap(NULL, REG_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, UART_BASE);
    if(base == MAP_FAILED) {
        perror("Failed to mmap UART registers");
        close(fd);
        return -1;
    }

    // 1. Configure RX baud rate and data format
    *(volatile uint32_t *)(base + RX_CLOCKFREQ_OFFSET)         = 50000000;  // Set RX system clock frequency to 25 MHz
    *(volatile uint32_t *)(base + RX_BAUDRATE_OFFSET)            = 115200;    // Set desired baud rate to 115200
    *(volatile uint32_t *)(base + RX_UPDATEBAUD_OFFSET)          = 1;         // Trigger RX baud rate update
    *(volatile uint32_t *)(base + RX_NUMOUTPUTBITSDB_OFFSET)   = 8;         // Configure for 8 data bits per frame
    *(volatile uint32_t *)(base + RX_USEPARITYDB_OFFSET)        = 0;         // Disable parity
    *(volatile uint32_t *)(base + RX_PARITYODDDB_OFFSET)        = 0;         // (Ignored if parity is disabled)

    // 2. Poll for data reception: wait until RX FIFO is not empty.
    // (Assuming RX_DATA_AVAILABLE returns a nonzero value when data is available.)
    while(*(volatile uint32_t *)(base + RX_DATAAVAILABLE_OFFSET) == 0) {
        usleep(1000);        // Wait for data to be received
    }

    // 3. Read the received data word
    uint32_t rx_data = *(volatile uint32_t *)(base + RX_DATA_OFFSET);
    printf("Received data: 0x%02X\n", rx_data);

    // 5. Check for any reception errors
    uint32_t err = *(volatile uint32_t *)(base + TOP_ERROR_OFFSET);
    if(err != 0) {
        printf("UART RX error: 0x%02X. Clearing error...\n", err);
        *(volatile uint32_t *)(base + CLEARERROR_OFFSET) = 1;
    }

    munmap((void *)base, REG_SIZE);
    close(fd);
    return 0;
}
\end{lstlisting}

\subsection{Configuration Workflow}

A typical configuration sequence is as follows:

\begin{enumerate}[noitemsep]
    \item \textbf{Set Baud Rates:}
    \begin{itemize}[noitemsep]
        \item Write the desired baud rate to TX\_BAUD\_RATE and RX\_BAUD\_RATE.
        \item Write the system clock frequency to TX\_CLOCK\_FREQ and RX\_CLOCK\_FREQ.
        \item Pulse TX\_UPDATE\_BAUD and RX\_UPDATE\_BAUD to trigger the baud generators.
    \end{itemize}

    \item \textbf{Configure Data Format:}
    \begin{itemize}[noitemsep]
        \item Set TX\_NUM\_OUTPUT\_BITS\_DB and RX\_NUM\_OUTPUT\_BITS\_DB to the desired number of data bits.
        \item Enable parity via TX\_USE\_PARITY\_DB and RX\_USE\_PARITY\_DB, and select odd/even with TX\_PARITY\_ODD\_DB and RX\_PARITY\_ODD\_DB if required.
    \end{itemize}

    \item \textbf{Initiate Transmission:}
    \begin{itemize}[noitemsep]
        \item Write the data word to TX\_DATA\_IN.
        \item Pulse TX\_LOAD to enqueue the data into the TX FIFO.
    \end{itemize}

    \item \textbf{Data Reception:}
    \begin{itemize}[noitemsep]
        \item Poll RX\_DATA\_AVAILABLE to determine if new data is ready.
        \item When available, issue a pop command (e.g., via a register control such as RX\_READ) and read RX\_DATA.
        \item Check RX\_ERROR for any reception errors and clear them using RX\_CLEAR\_ERROR.
    \end{itemize}
\end{enumerate}

\subsection{Error Conditions}

The UART module detects several error conditions:
\begin{itemize}[noitemsep]
    \item \textbf{Parity Error:} Occurs when parity checking is enabled and the received parity bit does not match the computed parity.
    \item \textbf{Framing Error:} Triggered when the expected stop bit is not detected.
    \item \textbf{Overrun Error:} Occurs if new data arrives before the previous word has been read from the RX FIFO.
    \item \textbf{Configuration Error:} Invalid configuration values (e.g., mismatched data bit settings) may trigger TOP\_ERROR.
\end{itemize}
Errors are reported in RX\_ERROR and can be cleared by writing ‘1’ to RX\_CLEAR\_ERROR.

